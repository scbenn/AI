Coding Demo Code:

import numpy as np
import tensorflow as tf
import os
 
import random
 
# Seed value
seed_value= 0
 
 
os.environ['PYTHONHASHSEED']=str(seed_value)
 
 
random.seed(seed_value)
 
np.random.seed(seed_value)
 
# 4. Set the `tensorflow` pseudo-random generator at a fixed value
tf.random.set_seed(seed_value)
 
 
# Suppress TensorFlow info logs
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
 
# Create synthetic data for demonstration
np.random.seed(0)
data = {
    'hour': np.random.randint(8, 18, size=200),  # Working hours from 8 AM to 5 PM
    'day_of_week': np.random.randint(1, 6, size=200),  # Days Monday to Friday
    'satisfaction': np.random.randint(1, 6, size=200)  # Satisfaction ratings from 1 to 5
}
df = pd.DataFrame(data)
 
# Define a simple neural network model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(10, activation='relu', input_shape=(2,)),  # Input layer for hour and day of the week
    tf.keras.layers.Dense(1)  # Output layer to predict satisfaction
])
 
# Compile the model with the Adam optimizer and mean squared error as the loss function
model.compile(optimizer='adam', loss='mean_squared_error')
 
# Prepare features and labels for training
features = df[['hour', 'day_of_week']]
labels = df['satisfaction']
 
# Train the model
model.fit(features, labels, epochs=20, verbose=1)
 
# Evaluate the model's performance
loss = model.evaluate(features, labels)
print(f'Model Loss: {loss:.2f}')
 
# Predict satisfaction scores for new appointment times
new_appointments = pd.DataFrame({
    'hour': [9, 14, 17],  # Example hours: 9 AM, 2 PM, 5 PM
    'day_of_week': [2, 3, 5]  # Example days: Tuesday, Wednesday, Friday
})
predictions = model.predict(new_appointments)
print("Predicted Satisfaction Scores:", predictions.flatten())
 
# Predict satisfaction scores for each hour of each workday
hours = np.arange(8, 18)  # Business hours from 8 AM to 5 PM
days = np.arange(1, 6)    # Monday to Friday
all_appointments = np.array(np.meshgrid(hours, days)).T.reshape(-1, 2)
 
predictions = model.predict(all_appointments)
predicted_satisfaction = predictions.flatten()
 
# Find the times with the highest predicted satisfaction scores
max_satisfaction_indices = np.argsort(-predicted_satisfaction)[:10]  # Get indices of top 10
best_times = all_appointments[max_satisfaction_indices]
 
print("Best times for scheduling appointments:")
for time in best_times:
    print(f"Hour: {time[0]}, Day of Week: {time[1]}")
 
# Assuming we have predictions for each hour and the impact of breaks
# Let's hypothetically improve satisfaction scores around typical break times (e.g., after lunch)
improved_hours = np.array([13, 14, 15])  # Assuming a lunch break at 12 PM
indices = np.where(np.isin(all_appointments[:, 0], improved_hours))
predicted_satisfaction[indices] += 0.5  # Hypothetically increase satisfaction post-break
 
# Evaluate the distribution of satisfaction over the day
print("Post-break improvement in satisfaction:")
for hour, satisfaction in zip(improved_hours, predicted_satisfaction[indices]):
    print(f"Hour: {hour}, Improved Satisfaction: {satisfaction}")
